import { Column, Connection, Database, Schema, Settings, Table } from "@/types";
import { getResponse } from "../ai";
import {
  createColumns,
  updateColumn,
  listColumns,
  deleteColumn,
} from "../columns";
import {
  ColumnDef,
  getConnectionSchema,
  getFullSchema,
  listRemoteDatabases,
  SchemaInfo,
  TableDef,
  updateConnection,
} from "../connections";
import {
  createDatabases,
  deleteDatabase,
  listDatabases,
  updateDatabase,
} from "../databases";
import {
  createSchemas,
  updateSchema,
  listSchemas,
  deleteSchema,
} from "../schemas";
import { getSettings } from "../settings";
import { createTables, updateTable, listTables, deleteTable } from "../tables";
import { createIndexJob, updateIndexJob } from "../jobs";
import {
  COLUMN_DESCRIPTION_PROMPT,
  CONNECTION_DESCRIPTION_PROMPT,
  DATABASE_DESCRIPTION_PROMPT,
  SCHEMA_DESCRIPTION_PROMPT,
  TABLE_DESCRIPTION_PROMPT,
} from "./prompts";

async function normalizeColumns(
  existingColumns: Column[],
  remoteColumns: ColumnDef[]
): Promise<void> {
  // Remove columns that exist locally but not remotely
  const remoteColumnNames = remoteColumns.map((col) => col.name);
  const columnsToDelete = existingColumns.filter(
    (existingCol) => !remoteColumnNames.includes(existingCol.name)
  );

  // Delete stale columns in parallel
  await Promise.all(columnsToDelete.map((col) => deleteColumn(col.id)));

  // Update existing columns if type changed
  const updatePromises = existingColumns
    .filter((existingCol) => remoteColumnNames.includes(existingCol.name))
    .map(async (existingCol) => {
      const remoteCol = remoteColumns.find(
        (rc) => rc.name === existingCol.name
      );
      if (remoteCol && existingCol.type !== remoteCol.type) {
        return updateColumn(existingCol.id, {
          ...existingCol,
          type: remoteCol.type,
        });
      }
    })
    .filter(Boolean);

  await Promise.all(updatePromises);

  // Log normalization actions
  if (columnsToDelete.length > 0) {
    console.log(
      `Normalized ${columnsToDelete.length} columns:`,
      columnsToDelete.map((col) => col.name)
    );
  }
}

async function normalizeTables(
  existingTables: Table[],
  remoteTables: TableDef[]
): Promise<void> {
  // Remove tables that exist locally but not remotely
  const remoteTableNames = remoteTables.map((table) => table.table);
  const tablesToDelete = existingTables.filter(
    (existingTable) => !remoteTableNames.includes(existingTable.name)
  );

  // Delete stale tables in parallel (cascade will handle columns)
  await Promise.all(tablesToDelete.map((table) => deleteTable(table.id)));

  // Log normalization actions
  if (tablesToDelete.length > 0) {
    console.log(
      `Normalized ${tablesToDelete.length} tables:`,
      tablesToDelete.map((table) => table.name)
    );
  }
}

async function normalizeSchemas(
  existingSchemas: Schema[],
  remoteSchemas: SchemaInfo[]
): Promise<void> {
  // Remove schemas that exist locally but not remotely
  const remoteSchemaNames = remoteSchemas.map((schema) => schema.name);
  const schemasToDelete = existingSchemas.filter(
    (existingSchema) => !remoteSchemaNames.includes(existingSchema.name)
  );

  // Delete stale schemas in parallel (cascade will handle tables and columns)
  await Promise.all(schemasToDelete.map((schema) => deleteSchema(schema.id)));

  // Log normalization actions
  if (schemasToDelete.length > 0) {
    console.log(
      `Normalized ${schemasToDelete.length} schemas:`,
      schemasToDelete.map((schema) => schema.name)
    );
  }
}

async function normalizeDatabases(
  existingDatabases: Database[],
  remoteDatabases: string[]
): Promise<void> {
  // Remove databases that exist locally but not remotely
  const databasesToDelete = existingDatabases.filter(
    (existingDb) => !remoteDatabases.includes(existingDb.name)
  );

  // Delete stale databases in parallel (cascade will handle all child entities)
  await Promise.all(databasesToDelete.map((db) => deleteDatabase(db.id)));

  // Log normalization actions
  if (databasesToDelete.length > 0) {
    console.log(
      `Normalized ${databasesToDelete.length} databases:`,
      databasesToDelete.map((db) => db.name)
    );
  }
}

export async function indexColumn(
  table: Table,
  column: ColumnDef,
  settings: Settings,
  schema: SchemaInfo,
  tableDef: TableDef,
  autoGenerateDescriptions = true
): Promise<Column> {
  // Check if column already exists
  const existingColumns = await listColumns(table.id);
  const existingColumn = existingColumns.find(
    (col) => col.name === column.name
  );

  let createdColumn: Column;

  if (existingColumn) {
    // Use existing column, update type if different
    if (existingColumn.type !== column.type) {
      createdColumn = await updateColumn(existingColumn.id, {
        ...existingColumn,
        type: column.type,
      });
    } else {
      createdColumn = existingColumn;
    }
  } else {
    // Create new column
    const [newColumn] = await createColumns([
      {
        table: table.id,
        name: column.name,
        description: null,
        type: column.type,
      },
    ]);
    createdColumn = newColumn;
  }

  if (
    !settings.aiFeatures.enabled ||
    (!settings.aiFeatures.providers.openai.apiKey &&
      !settings.aiFeatures.providers.anthropic.apiKey)
  ) {
    throw new Error("AI Features not configured");
  }

  // Only generate description if it's a new column or existing column has no description
  if (
    autoGenerateDescriptions &&
    (!createdColumn.description || existingColumn)
  ) {
    const prompt = COLUMN_DESCRIPTION_PROMPT.replace(
      "{schemaName}",
      schema.name
    )
      .replace("{tableName}", tableDef.table)
      .replace("{columnName}", column.name)
      .replace("{columnType}", column.type)
      .replace("{fullSchema}", JSON.stringify(schema, null, 2))
      .replace("{tableDefinition}", JSON.stringify(tableDef, null, 2))
      .replace("{columnDefinition}", JSON.stringify(column, null, 2));

    const { text } = await getResponse({
      apiKey: settings.aiFeatures.providers.openai.apiKey,
      provider: "Open AI",
      prompt,
    });

    const updated = await updateColumn(createdColumn.id, {
      ...createdColumn,
      description: text,
    });
    return updated;
  }

  return createdColumn;
}

export async function indexTable(
  schemaDef: SchemaInfo,
  schema: Schema,
  tableDef: TableDef,
  settings: Settings,
  autoGenerateDescriptions = true
): Promise<{ table: Table; columns: Column[] }> {
  if (
    !settings.aiFeatures.enabled ||
    (!settings.aiFeatures.providers.openai.apiKey &&
      !settings.aiFeatures.providers.anthropic.apiKey)
  ) {
    throw new Error("AI Features not configured");
  }

  // Get existing tables and normalize
  const existingTables = await listTables(schema.id);
  const existingTable = existingTables.find((t) => t.name === tableDef.table);

  let table: Table;

  if (existingTable) {
    // Use existing table and normalize its columns
    const existingColumns = await listColumns(existingTable.id);
    await normalizeColumns(existingColumns, tableDef.columns);
    table = existingTable;
  } else {
    // Create new table
    const [newTable] = await createTables([
      {
        description: null,
        name: tableDef.table,
        schema: schema.id,
      },
    ]);
    table = newTable;
  }

  const { columns } = tableDef;

  const promises = columns.map((c) =>
    indexColumn(
      table,
      c,
      settings,
      schemaDef,
      tableDef,
      autoGenerateDescriptions
    )
  );
  const results = await Promise.allSettled(promises);
  const indexedColumns = results
    .filter((i) => i.status === "fulfilled")
    .map((i) => i.value);

  // Only generate description if it's a new table or existing table has no description
  if (autoGenerateDescriptions && (!table.description || !existingTable)) {
    const prompt = TABLE_DESCRIPTION_PROMPT.replace(
      "{schemaName}",
      schemaDef.name
    )
      .replace("{tableName}", tableDef.table)
      .replace("{columnCount}", tableDef.columns.length.toString())
      .replace("{fullSchema}", JSON.stringify(schemaDef, null, 2))
      .replace("{tableDefinition}", JSON.stringify(tableDef, null, 2))
      .replace("{columnDefinitions}", JSON.stringify(indexedColumns, null, 2));

    const { text } = await getResponse({
      apiKey: settings.aiFeatures.providers.openai.apiKey,
      provider: "Open AI",
      prompt,
    });
    const updated = await updateTable(table.id, {
      ...table,
      description: text,
    });
    return { table: updated, columns: indexedColumns };
  }

  return { table, columns: indexedColumns };
}

export async function indexSchema(
  database: Database,
  schema: SchemaInfo,
  settings: Settings,
  autoGenerateDescriptions = true
): Promise<{ schema: Schema; tables: { table: Table; columns: Column[] }[] }> {
  if (
    !settings.aiFeatures.enabled ||
    (!settings.aiFeatures.providers.openai.apiKey &&
      !settings.aiFeatures.providers.anthropic.apiKey)
  ) {
    throw new Error("AI Features not enabled");
  }

  // Get existing schemas and check if this one exists
  const existingSchemas = await listSchemas(database.id);
  const existingSchema = existingSchemas.find((s) => s.name === schema.name);

  let schemaEntity: Schema;

  if (existingSchema) {
    // Use existing schema and normalize its tables
    const existingTables = await listTables(existingSchema.id);
    await normalizeTables(existingTables, schema.tables);
    schemaEntity = existingSchema;
  } else {
    // Create new schema
    const [newSchema] = await createSchemas([
      {
        database: database.id,
        name: schema.name,
        description: null,
      },
    ]);
    schemaEntity = newSchema;
  }

  const { tables } = schema;

  const promises = tables.map((t) =>
    indexTable(schema, schemaEntity, t, settings, autoGenerateDescriptions)
  );

  const results = await Promise.allSettled(promises);
  const indexedTables = results
    .filter((i) => i.status === "fulfilled")
    .map((i) => i.value);

  // Only generate description if it's a new schema or existing schema has no description
  if (
    autoGenerateDescriptions &&
    (!schemaEntity.description || !existingSchema)
  ) {
    const prompt = SCHEMA_DESCRIPTION_PROMPT.replace(
      "{schemaName}",
      schema.name
    )
      .replace("{tableCount}", schema.tables.length.toString())
      .replace("{databaseName}", database.name)
      .replace("{fullSchema}", JSON.stringify(schema, null, 2))
      .replace("{tableDefinitions}", JSON.stringify(indexedTables, null, 2));

    const { text } = await getResponse({
      apiKey: settings.aiFeatures.providers.openai.apiKey,
      provider: "Open AI",
      prompt,
    });
    const updated = await updateSchema(schemaEntity.id, {
      ...schemaEntity,
      description: text,
    });
    return { schema: updated, tables: indexedTables };
  }

  return { schema: schemaEntity, tables: indexedTables };
}

export async function indexDatabase(
  connection: Connection,
  database: string,
  settings: Settings,
  autoGenerateDescriptions?: boolean
): Promise<Database> {
  const { schemas } = await getFullSchema(connection, database);

  // Get existing databases and check if this one exists
  const existingDatabases = await listDatabases(connection.id);
  const existingDatabase = existingDatabases.find((db) => db.name === database);

  let databaseEntity: Database;

  if (existingDatabase) {
    // Use existing database and normalize its schemas
    const existingSchemas = await listSchemas(existingDatabase.id);
    await normalizeSchemas(existingSchemas, schemas);
    databaseEntity = existingDatabase;
  } else {
    // Create new database
    const [newDatabase] = await createDatabases([
      { connection: connection.id, name: database, description: null },
    ]);
    databaseEntity = newDatabase;
  }

  const promises = schemas.map((s) =>
    indexSchema(databaseEntity, s, settings, autoGenerateDescriptions)
  );

  const results = await Promise.allSettled(promises);
  const indexedSchemas = results
    .filter((i) => i.status === "fulfilled")
    .map((i) => i.value);

  // Only generate description if it's a new database or existing database has no description
  if (
    autoGenerateDescriptions &&
    (!databaseEntity.description || !existingDatabase)
  ) {
    const prompt = DATABASE_DESCRIPTION_PROMPT.replace(
      "{databaseName}",
      database
    )
      .replace("{schemaCount}", schemas.length.toString())
      .replace("{connectionType}", connection.engine || "Unknown")
      .replace("{fullSchemas}", JSON.stringify(schemas, null, 2))
      .replace("{schemaDefinitions}", JSON.stringify(indexedSchemas, null, 2));

    const { text } = await getResponse({
      apiKey: settings.aiFeatures.providers.openai.apiKey,
      provider: "Open AI",
      prompt,
    });
    const updated = await updateDatabase(databaseEntity.id, {
      ...databaseEntity,
      description: text,
    });

    return updated;
  }

  return databaseEntity;
}

export async function indexConnection(
  connection: Connection,
  autoGenerateDescriptions = false
): Promise<Connection> {
  const job = await createIndexJob({
    connection: connection.id,
    createdAt: new Date(),
    itemsProcessed: 0,
    itemsToProcess: 0,
    status: "processing",
    error: null,
  });

  console.log(`Beginning index on connection id ${connection.id}...`);

  try {
    const databases = await listRemoteDatabases(connection);
    const existingDatabases = await listDatabases(connection.id);

    // Normalize databases at the connection level
    await normalizeDatabases(existingDatabases, databases);

    const settings = await getSettings();
    const promises = databases.map((i) =>
      indexDatabase(connection, i, settings, autoGenerateDescriptions)
    );

    const indexedDatabases = await Promise.allSettled(promises);
    const successfulDatabases = indexedDatabases
      .filter((result) => result.status === "fulfilled")
      .map((result) => result.value);

    await updateIndexJob(job.id, { completedAt: new Date(), status: "done" });

    // Generate connection description if enabled and no description exists
    if (
      autoGenerateDescriptions &&
      settings.aiFeatures.enabled &&
      (settings.aiFeatures.providers.openai.apiKey ||
        settings.aiFeatures.providers.anthropic.apiKey) &&
      (!connection.description || connection.description.trim() === "")
    ) {
      try {
        const fullConnectionSchema = await getConnectionSchema(connection.id);

        const prompt = CONNECTION_DESCRIPTION_PROMPT.replace(
          "{connectionName}",
          connection.name || "Unnamed Connection"
        )
          .replace("{connectionEngine}", connection.engine || "Unknown")
          .replace("{databaseCount}", databases.length.toString())
          .replace(
            "{connectionHost}",
            connection.connection.host || "Unknown Host"
          )
          .replace(
            "{databaseDefinitions}",
            JSON.stringify(successfulDatabases, null, 2)
          )
          .replace(
            "{fullConnectionSchema}",
            JSON.stringify(fullConnectionSchema, null, 2)
          );

        const { text } = await getResponse({
          apiKey: settings.aiFeatures.providers.openai.apiKey,
          provider: "Open AI",
          prompt,
        });

        const updatedConnection = await updateConnection(connection.id, {
          ...connection,
          description: text.trim(),
        });

        return updatedConnection;
      } catch (descriptionError) {
        console.warn(
          `Failed to generate connection description: ${descriptionError}`
        );
      }
    }

    console.log(`Completed indexing on connection id ${connection.id}`);
    return connection;
  } catch (error: any) {
    console.error("Indexing failed ", error);
    await updateIndexJob(job.id, {
      error: error.message,
      completedAt: new Date(),
      status: "error",
    });
    throw error;
  }
}
